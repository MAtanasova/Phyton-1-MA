# Променливи:
# глобални - всяка която е в основната програма;
# ако някоя променлива в дадена функция е обявена с global,
# тогава функцията има достъп стойността на променливата от основната програма
# и може да я променя

# локални - е всяка променлива в коя да е функция, която не е обявена като global или nonlocal

# нелокални - всяка променлива от функция, която е обявена като nonlocal.
# Използват се при вложени функции, и обявената във вложената функция променлива като nonlocal
# реално има достъп и променя стойността на променлива външната функция

# # ************************
# x=10 # тук х е глобална променлива
# def външна():
#     # global x
#     x=5 # локална за "външна()"
#     def вътрешна():
#         x=7 # локална за "вътрешна"
#         return x
#     print(вътрешна())
#     return x
# print(x)
# print(външна())
# print(x)

# # ************************
# x=10
# def външна():
#     x=5 # локална за "външна"
#     def вътрешна():
#         nonlocal x
#         x=7 # нелокална за "вътрешна"
#         return x
#     print(вътрешна())
#     return x
# print(x)
# print(външна())

# # ************************
# x=10
# def външна():
#     x=5 # локална за "външна"
#     def вътрешна():
#         global x
#         x=7 # нелокална за "вътрешна"
#         return x
#     print(вътрешна())
#     return x
# print(x)
# print(външна())
# print(x)

# ************ реални, формални и локални параметри, позиционионни и ключови параметри ************
# позиционни - задължително трябва да подадем на функцията
# ключови - винаги са последвани от знака = и имат някаква стойност, НЕ е ЗАДЪЛЖИТЕЛНО да им се подава стойност
# при викането на функцията. Друготи им наименование: "параметри със стойности по подразбиране"

# def arithm(a0=1,d=1,n=10):
#       # съставяне на списък с членовете на аритметична прогресия с първи член а0=1,
#       # разлика d=1 и общ брой елементи 10
#     l=[a0+d*(i-1) for i in range(1,n+1)]
#     return l
#
# b,dd=2,3 # реални параметри (променливи)
# print(arithm()) #[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# print(arithm(b,dd)) #[2, 5, 8, 11, 14, 17, 20, 23, 26, 29], a0=2,d=3
# # формалните параметри a0 и d се свързват с реалните параметри b и dd
# print(arithm(d=2,a0=3)) #[3, 5, 7, 9, 11, 13, 15, 17, 19, 21], a0=3,d=2

# n=int(input("въведи брой на членовете на аритметичната прогресия: "))
# def arithm(n,a0=1,d=1):
#     # n е позиционен формален параметър, т.е. при викането на функцията задължително трябва да
#     # сложим някаква стойност за него
#     # а0 i d са формални ключови параметри, т.е. имат стойности по подразбиране
#     l=[a0+d*(i-1) for i in range(1,n+1)]
#     return l
# #   1)когато функцията приключва с return, то в главната програма обикновено използваме
# #   print (викаме функцията)
# #   2)когато функцията не приключва с return, а с print, то тогава в главната програма
# #   само викаме функцията без да се опитваме да я разпечатваме
# #   3) когато във функцията липсват print() и return, oбикновено се оказва, че сме
# #   променили някоя глобална променлива, и затова не е необходимо да показваме резултата
# #   от функцията чрез print() или да връщаме стойност с return към главната програма
#
# print(arithm(n))

# def arithm_err(a0=1,d=1,n): # Пример за грешно дефиниране на функция
#     l=[a0+d*(i-1) for i in range(1,n+1)]
#     return l

# def arithm(a0=1,d=1,n=10):
#     l=[a0+d*(i-1) for i in range(1,n+1)]
#     print(l)
# print(arithm())
# arithm()
# # Функция, която не завършва с Return, при отпечатване винаги ще връща NONE
#
# def Simples(a0=1,n=10):
#     # Да се изведат първите n прости числа, започвайки от a0
#     # i=0
#     L=[a0+i for i in range(n*n)]
#     print(L)
#     simples=[]
#     for l in L:
#         # взимаме поредното число l от списъка L
#         if len(simples)<n: # Докато не запълним simples със n на брой прости числа, да се изпълнява:
#             test=True # променливата test контролира добавянето към списъка има смисъла на:
#             # "поредното число l е просто число"
#             for k in range(2,l): # числата k са ни делителите и те се менят в рамките от 2 до l-1
#                 if l%k==0: # Ако намерим такова число k, което да може да раздели точно l:
#                     test=False # тогава променливата test=False, т.е. че числото l не е просто
#                     break # и прекратяваме по-нататъшната проверка за делимлост на осталите числа k
#             if test: #след като сме излезли от цикъла за k, проверяваме дали l е просто или не
#                 simples.append(l) # ако l e просто, т.е. ако test=True, тогава добавяме l към simples
#         else: break # осигурява изхода от цикъла за l когато броят на елементите в
#                     # simples е станала равен на n
#
#     return simples
# print(Simples(a0=11))


# Когато формален параметър се съпоставя с произволен брой аргументи, пред името му се слага *.
# Тогава той се съпоставя с редица от произволен брой подадени аргументи.
# Ако се съпоставя с ключови аргументи (когато съдържа "="), тогава пред името на формалния
# параметър се поставя **. Тогава той се съпоставя с речник.
# def some_fun_1(*a,**b):
#     print(a)
#     print(b)
# some_fun_1(1,2,3,name="Digits")
# >>>(1, 2, 3)
# >>>{'name': 'Digits'}


# D=dict()
# def some_fun_2(**b):
#     D.update(b) # ще добави новата двойка ключ-стойност в речника D
# some_fun_2(name="Валерия")
# some_fun_2(fname="Симеонова")
# some_fun_2(email="simeonova@fmi.uni-sofia.bg")
# print(D)


# D=dict()
# def some_fun_2(**b):
#     D.update(b) # ще добави новата двойка ключ-стойност в речника D

# L=[("ime1","fam1"),("ime1","fam2"),("ime2","fam1"),("ime2","fam2"),("ime1","fam3")]
# # да останат само двойки с неповтарящи ime1
# for l in L:
#     if l[0]=="ime1":
#         some_fun(ime1=l[1])
#     else:
#         some_fun(ime2=l[1])
# print(D)