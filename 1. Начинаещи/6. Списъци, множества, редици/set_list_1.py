x,y=5,7


# a= x and y
# еквивалентно на:
if x>=1:
    a=y
else:
    a=x
print(a)

# b=x or y
# еквивалентно на:
if x>=1:
    b=x
else:
    b=y
print(b)

# множества и операции над тях
set1={1, 2, 3, 4}
set2={3, 4, 5, 6}

# изключващо ИЛИ (XOR)
a=(set1 - set2) | (set2 - set1)
b=(set1 | set2) - (set1 & set2)
c=set1 ^ set2

a={1,3}
set1={1, 2, 3, 4}
s='a is sibset of set1'
for i in a:
    if i in set1: pass
    else:
        s='a is not sibset of set1'
        break
print('Вариант 1:\n'+s)

# any (някой от елементите) not in (не принадлежи на)

if any(a) not in set1:
    print('Вариант 2:\na is not sibset of set1')
if all(a) in set1:
    print('Вариант 3:\na is sibset of set1')

# превръщане на стринг в списък от стрингове с дължина единица:
*b,="extended" #['e', 'x', 't', 'e', 'n', 'd', 'e', 'd']
d=list("extended") #['e', 'x', 't', 'e', 'n', 'd', 'e', 'd']

# Обобщение на логически и побитовите логически оператори:
# and, or, not, any, all - оценяват изразите от ляво и дясно до True и False, връщат True или False или съответния пресметнат изращ
# &,|,^,~,>>,<< - прилагат се върху двоичния код на изразите, връщат резултат според първоначалния тип на данните

# Работа със списъци
L=['e', 'x', 't', 'e', 'n', 'd', 'e', 'd']
L.append(1) #добавя елемнт в края на списъка, и винаги само един елемент, подаваме стойност на новия елемент
L.remove(1) #изтриваме първия срещнат елемент от списъка със подадената стойност
L.extend([1,2,3]) # добавя поредица от елементи в края на списъка
L.index('t') # извежда индекса на първия срещнат елемент в списъка с посочената стойност
L.pop(0) #изтрива и връща елемент с посочения индекс
L.insert(0,65)
# 1) вмъква (увеличава броя на ел. на списъка с 1-ца,
# 2) измества всички елементи след посочения индекс с една позиция на дясно
# 3) на освободената позиция (която сме подали) се записва стойнпостта, която сме посочили
# Пример: измества всички елементи с една позиция на дясно и като първи елемент записва числото 65
L.append([1,2,3]) #добавя един елемент в края на списъка, който е от тип списък и има елементи 1,2,3
# [1,2,3] ще го наричаме подсписък
# Достъпване на елементи от подсписък:
L[-1][2] # от последния елемент на списъка L (който е подсписък) взимаме елемента с индекс 2

# Обратен ред (различно от сортиране) на елементите:
L[::-1] # само прочита елементите в обратен ред, без да променя списъка
L.reverse() # подрежда елементите в в списъка в обратен ред
L=L[::-1]
# 1) взима елементите на L в обратен ред и ги съхранява в анонимната променлива _
# 2) изтрива оригиналния списък L все едно, че използва командата del(L)
# 3) създава списък със същото име, но различно id
# 4) запълва новия списък със съдържанието на анонимната променлива
# недопустима операция: L=L.reverse(), L се оценява като NONE

# Сортиране на списък:
L.sort() # сортиране на елементите вътре в списъка, без да променя id-то, а само подредбата
sorted(L) # връща сортирания вид на елементите, но не променя самата подредба вътре в списъка
L=sorted(L)
# 1) взима елементите на L в сортиран ред и ги съхранява в анонимната променлива _
# 2) изтрива оригиналния списък L все едно, че използва командата del(L)
# 3) създава списък със същото име, но различно id
# 4) запълва новия списък със съдържанието на анонимната променлива
# недопустима операция: L=L.sort(), L се оценява като NONE

